{
"test_models.py": """from service import app
from service.models import Item, db
import pytest


@pytest.fixture(scope='module')
def setup_database():
    """ This fixture sets up an in-memory SQLite db for testing. """
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    app.config['TESTING'] = True
    app.config['DEBUG'] = False
    #Item.init_db(app)

    with app.app_context():
        db.create_all()  # Create all tables

    yield app

    with app.app_context():
        db.session.remove()
        db.drop_all()


@pytest.fixture
def client(setup_database):
    """ This provides a test client for Flask to simulate HTTP requests. """
    with setup_database.test_client() as client:
        yield client


def test_create_item():
    """ This should create a new Item. """
    text = 8 * 'a'
    item = Item(text=text)

    assert item is not None
    assert item.id is None
    assert text == item.text
""",
"models.py": """from flask_sqlalchemy import SQLAlchemy


db = SQLAlchemy()

def init_db(app):
    """ Initialize the SQLAlchemy app """
    Item.init_db(app)

class PersistentBase:
    def __init__(self):
        self.id = None

    @classmethod
    def init_db(cls, app):
        """ Initializes the database session """
        cls.app = app
        db.init_app(app)
        with app.app_context():
            db.create_all()

    @classmethod
    def get_all_accounts(cls):
        """ Returns all the records in the database """
        return cls.query.all()


    @classmethod
    def find_account_by_id(cls, by_id):
        """ Finds a record by its ID """
        return cls.query.get(by_id)

    def add_to_db(self):
        """
        Creates an Item and adds it to the database
        """
        self.id = None  # id must be none to generate next primary key
        db.session.add(self)
        db.session.commit()

    def update_db(self):
        """
        Updates an Item in the database
        """
        db.session.commit()

    def delete_from_db(self):
        """ Removes an Item from the database """
        db.session.delete(self)
        db.session.commit()


class Item(db.Model, PersistentBase):
    """
    Class for Item
    """
    app = None

    id = db.Column(db.Integer, primary_key=True)
    text = db.Column(db.String(200), nullable=False)

    def __repr__(self):
        return f'<Item {self.text}, id: {self.id}>'


""",
"routes.py": """from flask import render_template, request, redirect, url_for
from . import app
from service.models import Item

@app.route('/')
def index():
    items = Item.get_all_accounts()
    return render_template('index.html', items=items)

@app.route('/add', methods=('POST',))
def add_item():
    text = request.form.get('text')
    if text:
        item = Item(text=text)
        item.add_to_db()
    return redirect(url_for('index'))

@app.route('/edit/<int:id>', methods=('GET', 'POST'))
def edit_item(id):
    item = Item.find_account_by_id(int(id))
    if request.method == 'POST':
        item.text = request.form.get('text')
        item.update_db()
        return redirect(url_for('index'))
    return render_template('edit.html', item=item)

@app.route('/delete/<int:id>')
def delete_item(id):
    item = Item.find_account_by_id(int(id))
    item.delete_from_db()
    return redirect(url_for('index'))

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
"""
}

Tree Structure:
.
├── all_files.py
├── docker-compose.yml
├── output.txt
├── __pycache__
├── requirements.txt
├── run.txt
├── service
│   ├── Dockerfile
│   ├── __init__.py
│   ├── models.py
│   ├── __pycache__
│   │   ├── __init__.cpython-312.pyc
│   │   ├── models.cpython-312.pyc
│   │   └── routes.cpython-312.pyc
│   ├── requirements.txt
│   ├── routes.py
│   └── templates
│       ├── edit.html
│       └── index.html
└── tests
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-312.pyc
    │   └── test_models.cpython-312-pytest-8.3.3.pyc
    └── test_models.py

7 directories, 19 files
